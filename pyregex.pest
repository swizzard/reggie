// Python regex grammar
// ASCII only for now
backslash = { "\\" }
caret = { "^" }
dollar = { "$" }
dot = { "." }
l_sq = { "[" }
r_sq = { "]" }
l_parens = { "(" }
r_parens = { ")" }
l_brace = { "{" }
r_brace = { "}" }
lt = { "<" }
gt = { ">" }
eq = { "=" }
hash = { "#" }
colon = { ":" }
exclamation_mark = { "!" }
asterisk = { "*" }
plus = { "+" }
question_mark = { "?" }
hyphen = { "-" }
pipe = { "|" }
quant = _{ asterisk | plus | question_mark }
quantifier = { (num_times | quant) ~ (question_mark | plus)? }
num_times = _{
    l_brace ~
    (n_at_most | n_between | n_at_least | n_exact) ~
    r_brace
}
n_exact = { ASCII_DIGIT+ }
n_between = { ASCII_DIGIT+ ~ "," ~ ASCII_DIGIT+ }
n_at_least = { ASCII_DIGIT+ ~ "," }
n_at_most = { "," ~ ASCII_DIGIT+ }
literal = _{
    ASCII_ALPHANUMERIC | " " | "\t" | hash | ":" | eq | "_" | exclamation_mark | "\"" | "%" | "&" | "'" | "," | "/" | ";" | lt | gt | "@" | "`" | "~" 
}
zero_width_literal = @{ backslash ~ ("A" | "b" | "B" | "z" | "Z") }

set_literal = { literal | pipe | dollar | dot | l_parens | r_parens | l_brace | r_brace | plus | question_mark }
set_negation = @{ caret }
char_class = { backslash ~ char_class_label }
char_class_label = { "d" | "D" | "s" | "S" | "w" | "W" }
char_set = {
    l_sq ~ (set_negation | hyphen)? ~
    (char_range | set_literal | char_class | escaped_hyphen)+ ~
    (char_range | set_literal | char_class | escaped_hyphen | caret)* ~
    hyphen? ~ r_sq
}
escaped_hyphen = { backslash ~ hyphen }
range_bound = @{ !hyphen ~ ASCII }
char_range = { range_bound ~ hyphen ~ range_bound }
non_literal = _{ l_sq | r_sq | l_parens | r_parens | l_brace | r_brace | pipe }
literals = { !non_literal ~ literal+ }

backref = @{ backslash ~ ASCII_DIGIT+ }

exclusive_flag = _{ "a" | "L" | "u" }
negatable_flag = _{ "i" | "m" | "s" | "x" }
any_flag = _{ exclusive_flag | negatable_flag }
flags = { any_flag+ }
wpf_open = @{ l_parens ~ question_mark }
whole_pattern_flags = { wpf_open ~ flags ~ r_parens }

pattern_flags = { any_flag+ ~ (hyphen ~ negatable_flag+)? }
noncapturing = { pattern_flags? ~ colon }
atomic = { gt }
named = { "P" ~ lt ~ pattern_name ~ gt }
pattern_name = { (ASCII_ALPHANUMERIC | "_")+ }
named_backref = ${ "P=" ~ pattern_name }
pos_lookahead = @{ eq }
neg_lookahead = @{ exclamation_mark }
pos_lookbehind = @{ lt ~ eq }
neg_lookbehind = @{ lt ~ exclamation_mark }
ternary = { ternary_group ~ sub_pattern ~ (pipe ~ sub_pattern)? }
numbered_group_id = { ASCII_DIGIT+ }
named_group_id = { !ASCII_DIGIT ~ ASCII_ALPHANUMERIC+ }
ternary_group = { l_parens ~ ( numbered_group_id | named_group_id ) ~ r_parens }
group_ext = { question_mark ~
    (
        noncapturing |
        atomic |
        pos_lookahead |
        neg_lookahead |
        pos_lookbehind |
        neg_lookbehind |
        ternary |
        named_backref |
        named 
    )
}
group = { l_parens ~ group_ext? ~ sub_pattern* ~ r_parens }

comment_content = { (!r_parens ~ ANY)+ }
comment_group = { l_parens ~ question_mark ~ hash ~ comment_content ~ r_parens }

alt = _{ pipe ~ single_sub_pattern }

alternatives = { single_sub_pattern ~ alt+ }

single_sub_pattern = _{
    zero_width_literal |
    comment_group |
    ((group | literals | char_set) ~ quantifier?) |
    backref
}

sub_pattern = { alternatives | single_sub_pattern }
regex = { whole_pattern_flags? ~ sub_pattern+ }
